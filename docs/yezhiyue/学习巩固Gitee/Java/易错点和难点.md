
<font color=#ca0c16 size=8> Java疑难点

<a id="_top"></a>

@[TOC](文章目录)

# 基础

## 正确使用equals方法

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

1.1 不推荐使用方式，因为变量可能为null，会抛出空指针异常

```java
// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常
String str = null;
if (str.equals("SnailClimb")) {
  ...
} else {
  ..
}
```

1.2 推荐使用，使用功能确定的对象来调用equals，避免了空指针

```java
"SnailClimb".equals(str);// false 
```

1.3 更加推荐，JDK7中引入的工具类，直接避免了空指针(你使用就不用考虑对象前后顺序)

```java
Objects.equals(null,"SnailClimb");// false
// 源码如下
public static boolean equals(Object a, Object b) {
    // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。
    return (a == b) || (a != null && a.equals(b));
}
```

## 整形包装类值的比较

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

在Java中的大多数情况下，每次new都会创建一个新的对象，也就是有一个新的地址值产生。所以我们通常判断两个new出来的对象是不同的，但是对于包装类对象Integer是一个特例，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。所以虽然我们new出来了两个Integer对象，但是可能他们的地址是相同的。

```java
Integer x = 3;
Integer y = 3;
System.out.println(x == y);// true
Integer a = new Integer(3);
Integer b = new Integer(3);
System.out.println(a == b);//false
System.out.println(a.equals(b));//true
```

## BigDecimal

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

1.1 《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：
    
```java
    float a = 1.0f - 0.9f;
    float b = 0.9f - 0.8f;
    System.out.println(a);// 0.100000024
    System.out.println(b);// 0.099999964
    System.out.println(a == b);// false
```
    具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（精度丢失），我们如何解决这个问题呢？一种很常用的方法是：使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。
    
```java
    BigDecimal a = new BigDecimal("1.0");
    BigDecimal b = new BigDecimal("0.9");
    BigDecimal c = new BigDecimal("0.8");
    
    BigDecimal x = a.subtract(b); 
    BigDecimal y = b.subtract(c); 
    
    System.out.println(x); /* 0.1 */
    System.out.println(y); /* 0.1 */
    System.out.println(Objects.equals(x, y)); /* true */
```

1.2 BigDecimal 的大小比较

    a.compareTo(b) : 返回 -1 表示 a 小于 b，0 表示 a 等于 b ， 1表示 a 大于 b。
    
```java
    BigDecimal a = new BigDecimal("1.0");
    BigDecimal b = new BigDecimal("0.9");
    System.out.println(a.compareTo(b));// 1
```

1.3 BigDecimal 保留几位小数

    通过 setScale方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。
    
```java
    BigDecimal m = new BigDecimal("1.255433");
    BigDecimal n = m.setScale(3,BigDecimal.ROUND_HALF_DOWN);
    System.out.println(n);// 1.255
```

1.4 BigDecimal 的使用注意事项

    注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 BigDecimal(String) 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。
    
![](http://qft6wmzla.hn-bkt.clouddn.com/picgo/20200919092919.png?picgo)

1.5 总结

BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。

BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念

## 基本数据类型与包装数据类型的使用标准

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

Reference:《阿里巴巴Java开发手册》

- 【强制】所有的 POJO 类属性必须使用包装数据类型。
- 【强制】RPC 方法的返回值和参数必须使用包装数据类型。
- 【推荐】所有的局部变量使用基本数据类型。

比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.

说明 :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。

正例 : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险(空指针异常)。

反例 : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。

---

# 集合

## Arrays.asList()使用指南

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

1.1 Arrays.asList()将数组转换为集合后，其底层还是数组

![](http://qft6wmzla.hn-bkt.clouddn.com/picgo/20200919094142.png?picgo)

1.2 注意传入Arrays.asList()中的参数必须是对象数组，如果是基本类型数组容易出问题

```java
int[] myArray = {1, 2, 3};
List myList = Arrays.asList(myArray);
System.out.println(myList.size());//1
System.out.println(myList.get(0));//数组地址值
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException
int[] array = (int[]) myList.get(0);
System.out.println(array[0]);//1
```

当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。

所以我们可以用包装类创建这个数组 Integer[] myArray = {1, 2, 3};


1.3 使用集合的修改方法:add()、remove()、clear()会抛出异常。
    
```java
    List myList = Arrays.asList(1, 2, 3);
    myList.add(4);//运行时报错：UnsupportedOperationException
    myList.remove(1);//运行时报错：UnsupportedOperationException
    myList.clear();//运行时报错：UnsupportedOperationException
```

    Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。
    
```java
    List myList = Arrays.asList(1, 2, 3);
    System.out.println(myList.getClass());//class java.util.Arrays$ArrayList
```

源码实现如下

```java
  private static class ArrayList<E> extends AbstractList<E>
        implements RandomAccess, java.io.Serializable
    {
        ...

        @Override
        public E get(int index) {
          ...
        }

        @Override
        public E set(int index, E element) {
          ...
        }

        @Override
        public int indexOf(Object o) {
          ...
        }

        @Override
        public boolean contains(Object o) {
           ...
        }

        @Override
        public void forEach(Consumer<? super E> action) {
          ...
        }

        @Override
        public void replaceAll(UnaryOperator<E> operator) {
          ...
        }

        @Override
        public void sort(Comparator<? super E> c) {
          ...
        }
    }
```

我们再看一下java.util.AbstractList的remove()方法，这样我们就明白为啥会抛出UnsupportedOperationException。

```java
public E remove(int index) {
    throw new UnsupportedOperationException();
}
```

1.4 如何正确的将数组转换为ArrayList

- 简单转换

```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"))
```

- Stream转换

```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
```

## Collection.toArray()方法使用的坑&如何反转数组

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

该方法是一个泛型方法：<T> T[] toArray(T[] a); 如果toArray方法中没有传递任何参数的话返回的是Object类型数组。

```java
String [] s= new String[]{
    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"
};
List<String> list = Arrays.asList(s);
Collections.reverse(list);
s=list.toArray(new String[0]);//没有指定类型的话会报错
```

由于JVM优化，new String[0]作为Collection.toArray()方法的参数现在使用更好，new String[0]就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。


## 不要再foreach循环里面进行元素的remove/add操作

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

如果要进行remove操作，可以调用迭代器的 remove 方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身remove/add方法，迭代器都

> 将抛出一个ConcurrentModificationException,这就是单线程状态下产生的 fail-fast 机制。

```java
// Java8开始，可以使用Collection#removeIf()方法删除满足特定条件的元素,如

List<Integer> list = new ArrayList<>();
for (int i = 1; i <= 10; ++i) {
    list.add(i);
}
list.removeIf(filter -> filter % 2 == 0); /* 删除list中的所有偶数 */
System.out.println(list); /* [1, 3, 5, 7, 9] */
```

java.util包下面的所有的集合类都是fail-fast的，而java.util.concurrent包下面的所有的类都是fail-safe的。

![](http://qft6wmzla.hn-bkt.clouddn.com/picgo/20200919100144.png?picgo)