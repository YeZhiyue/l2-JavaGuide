<font color=#ca0c16 size=8> Java基础知识详解

<a id="_top"></a>

@[TOC](文章目录)

# 前言

<font color=#999AAA > 关于Java个人理解的学习总结，参考Gitee其他人的总结来融会贯通为个人的东西。

<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">

---

# Java基本功

## Java入门：基础概念与常识

### Java语言有哪些特点？

既然是特点，我们就需要从不同的方面进行分析

1. 和其他语言来比较，Java更加简单易学。没有C和C++一些繁杂的指针操作，Java有着良好的社区环境，提供了各种方便的库(C语言就没有这么方便)。而且Java面对对象的特点更加贴合我们的生活实际。

2. Java有面对对象的特点

3. 从不同操作系统平台上来看，Java代码的运行和平台无关，Java虚拟机实现了平台无关性。

4. Java代码还有可靠性、安全性

5. Java语言支持多线程。C++在2001年才提供了多线程支持

6. 从Java语言的设计初衷来说，Java支持网络编程。

7. 编译与解释并存。Java的虚拟机在设计上支持编译和解释执行代码，提高了代码的效率。

### JVM JDK JRE 的简单区分

Java虚拟机是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现(Windows,Linux,MacOS),目的是使用相同的字节码，他们都会给出相同的结果。

- 什么是字节码？采用字节码的好处是什么？

> 在Java中，JVM可以理解的代码就叫做字节码，他不面向任何特定的处理器，只面向虚拟机。Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释性语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译就可以在多种操作系统的额计算机上运行。

 补充，我们需要额外注意的是，在class文件转换到机器码的这个环节。是JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种执行方式会比较慢。而且，这些代码如果是经常被使用的热点代码，那么如果不进行特殊处理，通过JVM边解释边执行的方式来运行程序，速度会比较慢。所以JVM中引入了JIT编译器，可以将热点代码以机器码的方式保存下来，这些热点代码就不需要解释执行，直接交给操作系统执行，这样子会大大提高代码执行效率，所以我们Java被称之为编译和解释共存的语言。

> HotSpot采用了惰性评估做法，根据二八定律来找出热点代码(也就是消耗系统大部分资源的那一小部分代码)，然后通过JIT编译成机器码。在JDK9中引入了一种新的编译模式AOT，这样子的话就避免了JIT预热的开销。JDK支持分层编译和AOT协作使用，但是，AOT编译的质量肯定比不上JIT编译器的。

JDK是Java Development Kit ，也就是Java的开发者环境，有着齐全的SDK给开发者使用。而JRE是个Java Runtime Environment，是Java的运行环境，给非开发人员使用，只要你有了.class文件就可以运行。

### OracleJDK 和 OpenJDK

OpenJDK的起源：OpenJDK项目主要基于Sun捐赠的HotSpot源代码，OpenJDK是Java7的参考实现，Oracle工程师对OpenJDK进行维护。

OracleJDK和OpenJDK的区别：这两者非诚接近，OracleJDK是基于OpenJDK7构建的，OracleJDK在OpenJDK的基础上添加了很多插件和组件，OracleJDK趋向于商业用途，并不是全免费的。所以OracleJDK会更加稳定，有着强大的团队来维护OracleJDK。

### Java 和 C++ 的区别

- 都是面对对象的语言
- Java没有直接的指针可以操作内存，但是C++有
- Java的类是单继承的，C++的类支持多继承
- Java有着垃圾回收机制，不需要程序员手动释放内存，但是C++的内存都是需要程序员自动释放内存
- C语言中，字符串和字符数组最后都会有一个额外的字符'\0'来表示结束，但是Java语言中没有这个概念。

### 什么是Java程序的主类 应用程序和小程序的主类有何不同

一个程序可以有的多个类，但是只能有一个类是主类。

- 应用程序中：这个主类是值包含main()方法的类，这个主类可以不是public的。
- 小程序中：这个主类是一个继承自系统类JApplet或者Applet的子类，这个主类必须是public的。

### Java应用程序与小程序之间有哪些差别

主要是启动方式上的不同，应用程序时从main()方法中启动，但是小程序没有main()方法，主要是在浏览器页面上运行(调用init()或者run()来启动)。

### import java 和 javax 有什么区别

这需要从JDK的历史角度来说明这个问题，JDK的初始版本中JavaAPI的包都是以java.开头的，后台为了拓展API，引入了javax.的扩展包，当时javax还没有称为JavaAPI标准的一部分，所以如果想要使用javax的包会比叫麻烦，而且会破坏一堆现有的代码。所以最终javax成为了标准API的一部分。所以他们现在都是JavaAPI标准的一部分，也就没什么区别，区别只不过是在功能上的区别。    

### 为什么说Java语言"编译和解释并存"?

高级的编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是值编译期针对特定的操作系统将源代码一次性翻译成这个操作系统可以执行的机器码；解释型语言是值解释器对源程序助兴解释成特定操作系统的机器码并且立即执行。

在来看看Java的话我们可以得知Java代码的执行是先通过JVM将源代码编译为了.class文件，然后运行的时候通过JVM的解释器来将.class文件解释为操作系统认识的机器码。

## Java语法

### 字符型常量和字符串常量的区别

1. 形式上: 字符乘凉是单引号引起来的一个字符；字符串长岭是双引号引起来的0个或者若干个字符
2. 含以上，字符常量相当于一个整形值(ASCLL值)，可以参见表达式运算；字符串常量代表一个地址值(该字符串在内存中存放的位置)
3. 栈内存大熊字符串常量只占2个字节；字符春称量占若干个字节(char在Java中占用了两个字节)

字符封装类Character有一个成员常量Character.SIZE 值为16，单位是bits，该值除以8就可以得到两个字节

### 关于注释

3种注释

- 单行注释
- 多行注释
- 文档注释

子斌写代码的时候，如果代码量比较少，我们梓杰或者团队其他成员可以很轻易的看懂戴安，但是当项目结构一大半复杂起来，我们就需要用到注释了。注释并不会执行(编译器会在编译代码之前会把代码中的所有与注释抹掉，字节码中事实不会保留注释的)，是我们程序员写给自己看的，注释就是你代码的说明书，能够帮助看代码的人快速的理解代码之间的逻辑关系。

### 标识符和关键字的区别是什么

标识符就是我们程序、类、变量、方法的名字，用来区分。关键字就是Java预留的一些标识符，被Java赋予了特殊的含义，只有在特殊的地方才可以进行使用。

### 自增自检运算符

自增和自减运算符可以放在变量前，也可以放在变量后面。放在前面和表示先赋值然后参与运算，放在后面的表示先不赋值而参见运算。

### continue、break、和return的区别是什么

continue：指跳出当前的这一次循环，继续下一次循环。
break：跳出整个循环体，不继续执行剩下的循环体。

### Java泛型是什么？什么是类型擦除？介绍一下常用的通配符？

Java泛型时JDK5中引入的一个新特性，泛型提供了编译时类型安全监测机制，该机制允许程序员在编译时监测到非法类型。泛型的本质就是参数化类型，也就是说操作的数据类型指定为一个参数。

Java的泛型时伪泛型，所有的繁星信息都会被擦掉，这也及时通常所说的类型擦除。

### == 和 equals 的区别

1. == 的作用是判断两个对象的地址是否相等。也就是判断两个对象是不是同一个对象。基本数据类型比较的是值，引用数据类型比较的内存地址。
2. equals()比较两个对象是否相等，不能用于基本类型的比较。equals方法存在于Object类中，二Object类是所有类的直接父类。

### hashCode() 和 equals() 的区别

hashCode()的作用是获取哈希码，也称为散列码；他实际是返回一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object类中，这就意味着Java中的任何类都含有hashCode()函数。另外需要注意的是：Object的hashCode方法是本地方法，也即是C语言或者C++实现的，该方法通常用来将对象的内存地址转化为整数之后返回。

```java
public native int hashCode();
```

散列值存储的是键值对，它的特点是：能根据键快速的检索出对应的值，这其中就利用了散列码！(这样子就可以快速找到想要找的对象)

为什么要有hashCode？

我们一HashSet如何检索重复为例子来说明为什么要有hashCode？

> 当你把对象加入HashSet是，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时会与其他已经加入的对象的hashCode比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。但是如果发现有相同的hashCode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样子就会减少我们使用equals的次数，从而提高执行速度。

为什么重写equals是必须重写hashCode方法？

如果两个对象相等，则hashCode一定也是相同的。两个对象相等，对两个对象分别调用equals方法都返回true。但是，两个对象有相同的hashcode值，他们也不一定是相等的。因此，equals方法被覆盖过，那么hashCode方法也必须被覆盖。

> hashCode()的默认行为是对象的对象产生的独特值。如果没重写hashCode()，那么class的两个对象无论如何都不会相等(业技术记者两个对象是不会指向相同的地址)

为什么两个对象有相同的hashCode值，他们也不一定是相等的？

因为hashCode()所使用的杂凑算法也许会刚好让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关(所谓碰撞也就是指的是不同的对象得到相同的hashCode)

我们刚刚页提到了HashSet，如果HashSet在对比的时候，相同的hashCode有多个对象，他会使用equals()来判断是否真的相同。也就是说hashcode只是用来缩小查找成本。

## 基本数据类型

### Java中的集中基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？

1. 6中数字类型：byte、short、int、long、float、double
2. 1中字符类型：char
3. 1中布尔类型：boolean

这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean

### 自动装箱和拆箱

装箱：将基本类型用他们对应的引用类型包装起来
拆箱：将包装类型转换为基本数据类型

### 8种基本包装类和常量池

Java基本类型的包装类的大部分都实现了常量池技术，也就是Byte、Short、Integer、Long、Character、Boolean；前面4中包装类默认值创建了数值(-128,127)的响应类型的缓存数据，Character创建了在0-127范围的缓存数据，Boolean直接返回True 或者 False。如果超出对应范围仍然会常见新的对象。为啥把缓存值设置为 -128 ~ 127 区间？

## 方法(函数)

### 什么方法的返回值？返回值在类的方法里的租用是什么？

方法的返回值是我们获取到的某个方法中的代码执行后产生的结果。

### 为什么Java中只有值传递？

首先回顾一下在程序设计语言中有关参数传递给方法，或者函数的一些专业术语。按值调用表示方法接收的是调用者提供的子，而按引用调用表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用锁对应的变量值，而不能修改传递至调用所对应变量值。他用来描述各种程序设计语言。

Java程序中是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，如果是基本类型，那么直接拷贝这个变量的值，如果是一个对象，那么直接拷贝这个对象指向地址的值。】

### 重载和重写的区别

重载就是同样一个方法能够根据输入数据的不同，卓楚不同的处理。发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符不同。

重写就是子类继承自父类的的相同方法，输入数据一样，但是做出不同于父类的逻辑实现。重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。有以下的要求:返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰范围大于等于父类；如果父类的访问修饰符是private、final、static，那么子类就不能重写该方法，但是被static修饰的犯非法能够再次声明；构造方法无法被重写。

### 深拷贝 浅拷贝

1. 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递；
2. 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其中内容。

### 方法的四种类型

1. 无参无返回值的方法
2. 有参无返回值的方法
3. 有返回值无参数的方法
4. 有返回值有参数的方法

> return在无返回值方法的特殊使用

# Java面向对象

## 类和对象

### 面向对象和面向过程的区别

1. 现象对象和面向过程的区别

面向过程：面向过程性能比面向对象高。因为类调用时需要实力话，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux、Unix都是采用面型通过成开发的。但是面向过程没有面向对象容易维护、容易复用、容易拓展。
面向对象：面型对象容易维护、容易复用、容易拓展。因为面向对象有封装、继承、多态的特性，所以设计出低耦合的系统，使得系统更加灵活和容易维护。但是性能会比较低。

是不是所有的面向过程的语言性能都比面向对象高？面向过程的语言为什么性能会比较高？

Java性能差的主要原因并不是他是面向对象额的语言，而是Java是半编译语言，最终的执行代码并不是直接可以被CPU执行的二进制机械码。面向过程语言大多数是可以直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能不一定会比Java好。


### 构造器Constructor是否可以被override

不能被重写，但是可以重载。

### 在Java中顶一个不做事且没有参数的构造方法的作用

Java程序执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中"没有参数的构造方法"。因此，如果父类中只定义了有参的构造方法，而在子类的构造方法中有没有用super()来调用父类中特定的构造方法，那么编译的时候就会报错，因为Java程序再父类中找不到参数的构造方法可供执行。解决办法就是在父类中加上一个不做事且没有参数的构造方法。

### 成员变量和局部变量的区别有哪些？

1. 从语法形式上：成员变量属于类的，二局部变量是在代码块或者方法中定义的变量或者方法参数；成员变量可以被public、private、static等修饰符锁修饰，二局部变量不能被访问修饰符以及static修饰；但是，成员变量和局部变量都能被final所修饰。
2. 从变量在内存中的存储方式上来看：如果成员变量是用static修饰的，那么这个成员变量属于类的，如果没有使用static修饰，这个成员变量属于实例的。而对象存在于堆内存，局部变量存在于栈内存。
3. 从变量在内存中的生存时间上来看：成员变量是对象的一部分，随着对象的创建而存在，二局部变量锁着方法的调用二自动消失。
4. 成员变量如果没有被赋初值：则会自动根据类型进行默认值的赋值。除非这个成员变量被final修饰符修饰，那么这个变量必须被显示的赋值，但是局部变量不会被自动赋值。

### 创建一个对象用什么运算符？对象实体与对象引用有什么不同?

new运算符，new创建对象示例，对象是实例在堆内存，对象引用指向对象实例(对象引用存放在栈内存中)。一个对象引用可以指向0个或者1个对象；一个对象可以有n个引用指向它。

### 一个类的构造方法的作用是什么?如果一个类没有申明构造方法，该程序能正确执行吗？为什么？

作用：完成类对象的初始化工作。

如果没有构造方法是否可以执行：可以执行，因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法(无论是否有参数)，Java就不会再添加默认的无参数的构造方法，这个时候就创建对象就需要提供必需的参数了。

### 构造方法有什么特性？

1. 名字和类相同
2. 没有返回值
3. 生成类的对象是会自动执行，无需调用

### 在调用子类构造方法之前会掉一共父类没有参数的构造方法，其目的是？

帮助子类做初始化工作。

### 对象的额相等于指向他们引用的相等，两者有什么不同？

在Java中对象的相等通常指他们的内容相等，如两个Person对象，如果其中的name和age相同，我们就认为其中的内容相同，我们就可以从这个角度人为这两个对象是相等的。而引用相等值的是他们执行的内存地址是相等的。

## 面向对象的三大特征

### 封装

封装是值把一个对象的状态信息(也就是属性)隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法类操作属性。如我们不知道空调内部的零件信息，但是可以通过遥控器(可以理解为我们的方法)来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果衣蛾类没有提供给外界访问方法，那么这个类也就没有意义了。就好像只有一个空调但是没有了遥控器，空调就是一个摆设。

### 继承

不同类型的对象，相互之间经常有一定数量的共同点。例如：人，都有着姓名、年龄两种属性。但是对于不同职业的人，如老师、学生，在他们身上都有着姓名、年龄两种属性，但是还有一些属性是不同的，如他们职位属性。使用了继承我们就可以使用继承，重用其中的姓名、年龄属性，提升代码的重用和程序的可维护型，节省大量创建新类的时间，提升开饭效率。

补充：

1. 子类拥有父类对象的属性和方法(包括私有属性和私有方法)，但是父类中的私有属性和方法是无法被子类直接访问的，只是拥有。
2. 子类可以拥有自己属性的方法，即子类可以对父类进行拓展。
3. 子类可以用自己的方式实现父类的方法。

### 多态

多态，顾名思义，表示一个对象具有多种形态。具体表现为父类的引用执行子类的实例。

特点：

1. 对象类型和引用类型之间具有继承类、实现接口的关系。
2. 对象类型不可变，引用类型可变。
3. 方法具有多态性，属性不有多态性。
4. 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定。
5. 多态不能调用只在子类存在但是在父类中不存在的方法。
6. 如果子类重写了父类的方法，真正执行是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

## 修饰符

### 在一个静态方法内调用一个非静态成员为什么是非法的？

由于静态方法可以不通过对象进行调用，因为在静态方法里，不能调用其他非静态变量，页不可以访问非静态变量成员。

### 静态方法和实例方法有何不同

1. 在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象名.方法名 的方式。
2. 静态方法可以反问本类的成员是，只允许访问静态成员(静态成员变量和静态方法)，二不允许访问示例成员变量和实例方法。实例方法没有这个限制。

### 常见关键字总结:static、final、final、this、super

## 接口和抽象类

### 接口和抽象类的区别是什么

1. 接口的方法默认是public，所有的方法在接口中不能有实现，而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但是只能实现一个抽象类。接口自己本身可通过extends关键字拓展多个接口。
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符(抽象方法就是为了被重写所以不能使用private关键字修饰)
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

> 在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用。如果同时实现两个接口，接口中定义一样的默认方法，则必须重写，不然会报错。
> JDK9的接口被允许定义私有方法。

1. 在jdk7或作者更早的版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选选择实现接口的类实现。
2. jdk8的时候接口可以有默认方法和静态方法功能。
3. jdk9在接口中引入了私有方法和私有静态方法。

## 其他重要知识点
    
### String StringBuffer StringBuilder 的去呗？ String为什么是不可变得？

简单来说，String类中使用了final关键字修饰字符数组来保存字符串，private final char value[],所以String对象是不可变的。

补充：Java9之后String类的实现改用byte数组存储字符串。

StringBuilder与StringBuffer都是继承自AbstractStringBuilder类，在这个AbstractStringBuilder中也是使用字符数组保存字符串char[] value，但是没有使用final关键字修饰，所以这两种对象都是可变的。

StringBuilder与StringBuffer的构造方法都是调用父类构造方法也就是AbstractStringBuilder实现的，大家可以自行查阅源码。

线程安全性上的比较

String中的对象是不可变的，也就是可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以hi非线程安全的。

性能

每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针执行新的String对象。StringBuffer每次都会对StringBuffer对象本身进行从操作，而不是生成新的对象并且改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅仅能提升10%~15%左右的性能提升。

总结：

- 操作少量数据，适用String
- 单线程操作字符串缓冲区下操作大量数据：适合使用StringBuilder
- 多线程操作字符串缓冲区下操作大量数据：适合使用StringBuilder

### Object类的常见方法总结

Object是一个特殊的类，是所有类的父类。主要提供了以下的11个方法。

```java
public final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。

public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。
public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。

protected native Object clone() throws CloneNotSupportedException//native方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。

public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。

public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。

public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。

public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。

public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。

public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念

protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作
```

### == 和 equals 重要

== ：比较两个对象的地址值是不是相等的，如果是基本类型那么就是比较值是否相等。
equals() : 作用也是比较两个对象是否相等。

- 情况一：类没有覆盖equals()方法。则通过equals()比较两个对象时，等价于比较两个对象的地址。
- 情况二：类覆盖了了equals()方法。。一般，我们都覆盖了equals()方法来比较两个对象的内容是否相等；若他们的内容相等，则返回true

### hashCode 和 equals

hashCode()的作用是获取哈希码，也称之为散列码；这个值实际上是一个int整数。这个哈希码的作用是确定这个对象在哈希表中的索引位置。hashCode()定义在JDK的Object.java中，这就意味着任何类都包含有hashCode()函数。

为什么Java中重写equals()的时候必须重写hashCode()?

这是因为在Java中有相关的规定

如果两个对象相等，则 hashcode 一定也是相同的
两个对象相等,对两个对象分别调用 equals 方法都返回 true
两个对象有相同的 hashcode 值，它们也不一定是相等的
因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖
hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)

### Java序列化中如果有些字段不想进行序列化，怎么办？

我们可以使用transient关键字来修饰这些不想序列化的字段。

transient关键字的作用：阻值实例中那些用此关键字修饰的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。

### 获取用键盘输入常用的两种方法

方法一：通过Scanner

Scanner input = new Scanner(System.in);
String s = input.nextLine();
input.close();

分发二：通过BufferedReader

BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
String s = input.readLine();

# Java核心技术

## 集合

### Collections 工具类和 Arrays 工具类常见的方法总结

## 异常

![](https://gitee.com/SnailClimb/JavaGuide/raw/master/docs/java/images/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png)

在Java中，所有的异常都有一个共同的祖先java.lang包中的Throwable类。Throwable：有两个重要的子类：Exception和Error，这两个都是异常处理重要的子类。

Error：是程序无法处理的错误，表示运行应用层序中较严重的问题。大多数错误与代码便携装执行的操作无关，而必要时代码运行JVM出现的问题。例如，Java虚拟机运行错误，当JVM不再有继续执行操作所需要的内存资源是，将出现内存溢出异常。这些异常一般会导致Java虚拟机的线程终止。

Exception：是程序本身可以处理的异常。Exception类有一个重要的子类RuntimeException。RuntimeException异常由Java虚拟机抛出。NullPointerException(要访问的变量没有引用任何对象时会抛出这个异常)、ArithmeticException(算数运算异常，一个整数除以0时，抛出这个异常)和ArrayIndexOutOfBoundException(下标越界异常)。

异常和错误的区别：异常能够被程序本身处理，错误是无法处理的。

### Throwable 类常用方法

public String getMessage():返回异常发生时的简要描述
public String toString():返回异常发生时的详细信息
public String getLocalizedMessage():返回异常的本地haul信息。使用Throwable的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖这个方法，则这个方法返回的信息和getMessage()的结果相同。
public void printStackTrace():在控制台打印Throwable对象封装的异常信息。

### try-catch-finally

try：用于捕获异常。后面可以跟上0个或者多个catch块，如果没有catch那么后面必须跟一个finally块。
catch：用于处理try捕获到的异常。
finally：无论是否捕获异常，finally块里面的语句都会被执行。当在try或者catch中遇到return语句时，finally语句块将在方法返回之前被执行。

特殊情况补充：

1. 在finally语句块的第一行发生了异常。
2. 在前面的代码块中用了System.exit(int)已经退出程序。exit是带参函数；若改与极具在异常语句之后，finally会执行
3. 程序所在的线程死亡
4. 关闭CPU

注意：finally语句块中的return会覆盖try语句块中的返回值。

### 使用 try-with-resources 来代替 try-catch-finally

1. 适用范围：任何实现了 java.lang.AutoCloseable 或者 java.io.Closeable
2. 关闭资源和final的执行顺序:任何catch或者finally语句块在资源关闭后执行

## 多线程

### 简述线程、程序、进程的基本概念。以及他们之间关系hi什么？

线程与进行相似，但是线程是一个比进程更小的执行单元。一个进行在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享一块内存空间和一组系统资源，所以系统在产生一个线程，或者是在各个线程之间作切换工作时，负担要比进行小得多，也正因为如此，线程也被称为轻量级进行。

程序是含有指令和数据的文件，被存储在磁盘或者其他数据存储设备中，也就是说程序时静态的代码。

进程是程序的一次执行过程，是系统与进行程序的基本单位，因此进行是动态的。系统运行一个程序就是一个进行的创建，运行到消亡的过程。简单来说，一个进行就是一个执行中的程序，他在计算机中一个指令接着一个执行地执行，同时，每个进行还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等。换句话说，当程序在执行时，将会被操作系统载入内存中。线程时进行划分成更小的运行单位。线程和进行最大的不同在于基本上各进行是独立的，但是各线程则是不一定的，因为同一个进程中线程极有可能划分成更小的运行单位。线程和进程最大的不同在于基本上各个进程是独立的，而各个线程时不一定，因为同一个进程中的线程很有肯能会相互影响。从另一个角度来说，进程数据操作系统的范畴，主要是同一个时间内，可以同时执行一个以上的程序，而线程是同一个程序内几乎同时执行的一个以上的程序段。

### 线程有哪些基本状态？

Java线程有6中不同的状态

NEW 初始状态，县城北构建，但是还没有调用start()方法
RUNNABLE 运行状态，Java线程将操作系统中的就绪和运行两种这状态笼统的称作 运行中
BLOCKED 阻塞状态，表示线程阻塞于锁
WAITING 等待状态，表示线程进入等待状态
TIME_WAITING 超时等待装那台，该状态不同于WAITING，他是可以在指定的时间自行返回的
TERMINATED 终止状态，表示当前线程已经执行完毕

## 文件与I\O流

### Java中IO流分为几种

- 按照流的方向分，分为输入流和输出流
- 按照操作单元分，分为字节流和字符流
- 按照留的角色分，分为节点流和处理流

JavaIO流共涉及到40多个类，这些类看上去很杂乱，但是实际上很有规则，而且彼此之间存在非常精密的联系，JavaIO流的40多个类都是从如下4个抽象类积累中派生出来的

- InputStream/Reader 字节输入流&&字符输出流
- OutputStream/Writer 字节输出流&&字符输出流

### 既然有了字节流，为什么还要有字符流？

问题本质想问：不管是文件读写还是网络发送接收，信息的最小的存储单元都是字节，那么为什么IO流的操作要分为字节流操作和字符流操作？

答：字符流是由Java虚拟机将字节转换得到的，问题就虚线在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题(字符流我们可以指定编码，这样子就减少了错误，提高了转换效率)。所以，IO流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果是音频之类的媒体问价你还是推荐使用字符流。

### BIO，NIO，AIO有什么区别

1. BIO(Blocking IO):同步阻塞IO模式，数据的读写必须阻塞在一个线程内等待其完成。在活动连接数不是特别高(小于单机1000)的情况下，这种模式还是比较不错的，可以让每一个连接专注于自己的IO并且编程模型简单，也不用过多考虑系统的过载、限流的问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或者请求。但是，面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。因此，我们就需要更加高效的IO处理模型来应对更高的并发量。
2. NIO(Non-blocking IO):NIO是一种同步非阻塞的IO模型，在Java1.4中引入了NIO模型，对应java.nio包，提供了Channel，Selector，Buffer等抽象。它支持面向缓冲的，基于通道的IO操作方法。NIO提供了BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统的支持一样，比较简单，但是性能和可靠性都不是很好。非阻塞刚好与之相反。对于低负载、低并发的盈余公程序，可以使用同步阻塞IO来提升开发效率和更好的维护性；对于高负载、高并发的网络应用，应使用NIO的非阻塞模式来开发。
3. AIO(Asynchronous IO):AIO也就是NIO2。Java7引入了NIO的改进版NIO2，他是异步非阻塞的IO模型。异步IO是基于时间和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续操作。AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞方法，但是NIO的IO行为还是同步的。但是AIO的是使用还不是非常广泛，Netty之前尝试使用AIO但是后来还是放弃了。





