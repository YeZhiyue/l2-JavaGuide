
---

<a id="_1.1"></a>

## `索引案例学习`

--- 

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

P94页

---

<a id="_1.1"></a>

**1. 根据选择性高的列上建立索引**

--- 

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

选择性的简单判断：通常来说，字段中重复的值越少，选择性就越高，反之越低。例如 sex、county 列中就是sex的选择性比较低，因为通常只有个 f、m 两种值可供选择。

如果没有对一张表中建立多个索引的需要的话，我们通常选择选择性高并且经常用来过滤的字段进行索引。

---

<a id="_1.2"></a>

**2. 多列索引的诀窍，使用in(...)操作**

--- 

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

在上面讨论了根据选择性高低来决定索引，这里我们列举一些特殊情况，我们建立索引的操作会看上去背离上面的原则。

同样还是sex、county字段，我们建议创建不同组合索引的时候将(sex，country)中的sex列作为前缀，尽管sex字段的选择性比较低。这是为什么呢？这里需要从两个方面结合来说，第一个比较容易理解，因为很多过滤操作都会涉及到sex列的过滤，但是这并不是主要原因，主要原因是我们可以通过一种特殊的过滤组合来在这种情况下提升性能，如果有语句不需要通过sex列来进行数据过滤，那么我们就可以在查询条件中新增AND SEX IN('m','f')来提升性能，这样子county字段上的索引就会有很大的勇武之地了，因为添加上这个过滤条件几乎对不会拉低性能，而且这使得MySQL匹配到了索引的最左前缀，但是前提条件是这个in过滤的所有字段值可以枚举出来，否则就要考虑将这个字段后移。

---

<a id="_1.3"></a>

**3. 组合索引技巧，将范围过滤的字段后移**

--- 

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

如果我们需要为一些比较生僻的搜索条件添加到组合索引中，我们改怎么为组合索引确定一个先后顺序呢，如 has_picture\eye_color...，并且这时候组合索引是(sex\county\age)，那么会考虑将age后移，为什么呢，因为age通常是范围查询，写出来的过滤条件大多数如 20 < age and age < 40 这样的，而MySQL中查询只能使用索引的最左前缀，直到遇到第一个范围查询，当然age也可以写成非范围查询，但是这个情况出现的情况可能会比较少。将age后移，我们可以通过 in 技巧来对前面的字段进行优化。但是需要注意一点就是使用in的时候我们需要考虑他们的组合情况，如果组合情况达到了上千个，那么我们就需要考虑是否使用索引了，老版本在in组合中会有很多问题，查询优化会小号很多时间并且消耗大量的内存，但是新版本的MySQL会对组合进行评估，在组合数量超过一定数量后就不在进行执行计划评估了。

---

<a id="_1.4"></a>

**4. 优化排序，使用延时查询**

--- 

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

P 194 

在涉及到排序分页的SQL时，我们可以使用延时查询来提升性能，也就是缓存临时表的方式来实现。

---

<a id="_2"></a>

## `查询为什么会慢 SQL优化`

--- 

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

---

<a id="_2.1"></a>

**1. 查询为什么会慢**

--- 

*<a href="#_top" rel="nofollow" target="_self">返回目录</a>*

1.1 数据库查询SQL执行的流程

查询的生命周期：从客户端到服务器，然后服务器解析，生成执行计划，执行，最后返回结果给客户端。

其中执行是最为复杂的阶段：有着大量对存储引擎的调用以及调用后的数据处理，包括排序、分组。

花费时间的地方：网络，CPU计算，生成统计信息，执行计划，锁的等待(如写锁，也就是互斥锁)

1.2 如何让查询变快

其实我们的SQL查询中可能会花大量时间在没有必要检索的数据上，我们减少这些没有必要的检索就实现了SQL的优化

1.3 使得性能下降的SQL查询

错误一：查询时使用通配符 * 返回所有列，这样子会给服务器带来额外的IO、内存和CPU消耗，并且数据库的优化器在这种情况下无法完成索引覆盖扫描优化。

错误二：重复查询相同的数据，常见的操作是对数据库进行遍历SQL查询，这样子会导致性能的急剧下降，我们最好先将所有数据查询出来然后缓存下来之后在进行操作。

1.4 衡量SQL查询开销的三个指标

响应的时间、扫描的行数、返回的行数


