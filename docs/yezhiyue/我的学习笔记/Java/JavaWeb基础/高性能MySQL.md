
1.1 切分查询 SQL优化

有时候我们完成一个大查询的时候我们需要分而置之，将大查询分成小查询，每个查询功能完全一样，只是完成其中的一小部分。

使用场景：在定期删除大量的数据的时候如果用一个大的语句异性完成的话，一次可能需要锁住很多数据、沾满整个事务日志、耗费系统资源、组设很多小的但是重要的查询。将一个大的delete语句切分成多个较小的查询可以尽可能小的影响MySQL性能，同时可以减少MySQL复制的延迟。

- delete from message where created<date_sub(now(),interval 3 month);

优化方式如下：分而治之,也就是不要讲服务器上原本一次性的眼里分散到一个很长的时间段中，这样子就可以大大降低对服务器的影响。

```java
rows_affected = 0 
do{
    rows_affected = do_query(
        "delete from message where created < date_sub(now(),interva 3 month) limit 10000"
    )
} while rows_affected>0
```


查询原理初探

1.1 通信协议

MySQL客户端好服务器之间的通信协议是“半双工”的，这意味着在任何一个时刻，要么是由服务器发送数据给客户端，反之亦然，两个动作不能同时发生。

1.2 MySQL线程状态

- sleep 线程正在等待客户端发送新的请求
- query 线程正在执行查询或者正在将结果发送给客户端
- locked 在MySQL服务器层，该线程正在等待表锁，在存储引擎级别实现的锁，例如InnoDB的行锁，并不会体现在线程的状态中。
- Analyzing and statistics 线程正在收集存储引擎的统计信息，并声称查询的执行计划
- Copying to tmp table [on disk] 线程正在执行查询，并且将结果集都复制到一个临时表中，这种状态一般要么是再做group by 操作，要么是排序操作，或者是union操作。如果这个状态后面还有on disk 标记，那么表示MySQL正在将一个内存临时表防盗磁盘上。
- sorting result 线程正在对结果集进行排序
- sending ddata 这表示多种情况：线程可能在多个状态之间传送数据或者生成结果集，或者在向客户端返回数据。

== 查询缓存

在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希表实现的。查询和缓存中的查询即使只有一个字节不同，那也不会缓存结果，这种情况下查询就会进入1下一个阶段。

== 查询缓存完毕之后下一步就是将SQL转换成一个执行计划，MySQL在依照这个计划和存储引擎进行交互。这包括多个子查询：解析SQL、预处理、优化SQL执行计划。这个过程之中任何错误都会终止查询。

== 语法解析器和预处理

Mysql通过关键字将并且语句进行解析，并且声称一颗对应的解析树，MySQL解析器将使用MySQL语法规则验证和解析查询。例如，他讲验证是否使用错误的关键字，或者使用关键字的书序是否正确再或者他还会验证英豪是否能前后正确匹配。

下一步预处理器会验证权限。者通常会很快，除非服务器行业有非常多的权限配置。

== 查询优化器

现在语法书被认为是合法的了，并且有优化器将其阿转化成执行计划。一条查询可以有恒多种执行方式，最后返回相同的结果。优化器的作用就是找到其中最好的执行计划。


